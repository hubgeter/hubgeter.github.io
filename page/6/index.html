<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>daidai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="daidai">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="daidai">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="daidai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="daidai" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">daidai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-note/网络编程/tmp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tmp/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>当进程向某个已收到RST的套接字执行写操作时，内核向进程发送SIGPIPE 信号，该信号默认行为是终止进程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tmp/" data-id="clh7j8wpk001p2waickmxdgyw" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/网络编程/多路复用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>描述符就绪条件：<br>大于等于套接字缓冲区低水位标记  SO_RCVLOWAT<br>连接的读&#x2F;写半连接关闭<br>监听套接字 且完成的连接数不为0 &#x2F; <strong>非阻塞式connect的套接字已建立连接</strong><br>套接字错误待处理</p>
<p>当套接字上发生错误时，select 标记为即可读又可写</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typesizes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">#define__FD_SETSIZE <span class="number">1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FD_SETSIZE__FD_SETSIZE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> int__fd_mask;</span><br><span class="line">#undef__NFDBITS</span><br><span class="line">#<span class="built_in">define__NFDBITS</span>(<span class="number">8</span>*(<span class="type">int</span>)<span class="built_in">sizeof</span>(__fd_mask))</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">#ifdef__USE_XOPEN</span><br><span class="line">    __fd_mask fds_bits[__FD_SETSIZE/__NFDBITS];</span><br><span class="line">    #<span class="built_in">define__FDS_BITS</span>(set)((set)-＞fds_bits)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    __fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS];</span><br><span class="line">    #<span class="built_in">define__FDS_BITS</span>(set)((set)-＞__fds_bits)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;fd_set;</span><br><span class="line"><span class="comment">//fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set*fdset);<span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd,fd_set*fdset);<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd,fd_set*fdset);<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="type">int</span> fd,fd_set*fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span><span class="params">(<span class="type">int</span> nfds,fd_set* readfds,fd_set* writefds,fd_set* exceptfds, <span class="keyword">struct</span> timeval*timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span>&#123;</span><br><span class="line">    <span class="type">long</span> tv_sec;<span class="comment">/*秒数*/</span></span><br><span class="line">    <span class="type">long</span> tv_usec;<span class="comment">/*微秒数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">nfds参数指定被监听的文件描述符的总数。</span></span><br><span class="line"><span class="comment">它通常被设置为 select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。三个参数都是值-结果参数。</span></span><br><span class="line"><span class="comment">数组的每个元素的每一位（bit）标记一个文件描述符</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序select等待了多久</span></span><br><span class="line"><span class="comment">如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。</span></span><br><span class="line"><span class="comment">select成功时返回就绪（可读、可写和异常）文件描述符的总数。</span></span><br><span class="line"><span class="comment">如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>当用户process调用select的时候，select会将需要监控的readfds集合<strong>拷贝到内核空间</strong>（假设监控的仅仅是socket可读），然后遍历自己监控的socket sk，挨个调用sk的poll逻辑以便检查该sk是否有可读事件，遍历完所有的sk后，如果没有任何一个sk可读，那么select会调用<em>schedule_timeout</em>进入schedule循环，使得process进入睡眠。如果在timeout时间内某个sk上有数据可读了，或者等待timeout了，则调用select的process会被唤醒，接下来select就是遍历监控的sk集合，挨个收集可读事件并返回给用户了</p>
<p>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的 事件，另一方面由于<strong>内核对fd_set集合的在线修改</strong>，<strong>描述符集合内任何与未就绪描述符对应的位返回时均清为0</strong>，应用程序下次调用 select前不得不重置这3个fd_set集合。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>能监听端口的数量有限；</p>
<p>被监控的fds集合中，只要有<em>一个有数据可读</em>，整个socket集合就会被遍历一次调用sk的poll函数收集可读事件</p>
<p>内核对fd_set集合的在线修改，应用程序下次调用 select前不得不重置这3个fd_set集合</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span>&#123;</span><br><span class="line">    <span class="type">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line">    <span class="type">short</span> events;<span class="comment">/*注册的事件*/</span></span><br><span class="line">    <span class="type">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd*fds,<span class="type">nfds_t</span> nfds,<span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>poll改变了fds集合的描述方式，使用了pollfd结构而不是select的fd_set</p>
<p>内核每次修改的是pollfd结构体 的revents成员，而events成员保持不变，因此下次调用poll时应用程序<strong>无须重置</strong>pollfd类型的事件集参数</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>深入理解 epoll</p>
<p>epoll把用户关心的文件描述符上的事件放在<em>内核里的一个<strong>事件表</strong></em>中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一 标识内核中的这个事件表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">//size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</span></span><br><span class="line"><span class="comment">//该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd,<span class="type">int</span> op,<span class="type">int</span> fd,<span class="keyword">struct</span> epoll_event*event)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">EPOLL_CTL_ADD，往事件表中注册fd上的事件。</span></span></span><br><span class="line"><span class="comment"><span class="function">EPOLL_CTL_MOD，修改fd上的注册事件。</span></span></span><br><span class="line"><span class="comment"><span class="function">EPOLL_CTL_DEL，删除fd上的注册事件。</span></span></span><br><span class="line"><span class="comment"><span class="function">event参数指定事件</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">struct</span> epoll_event</span>&#123;</span><br><span class="line">    <span class="type">__uint32_t</span> events;<span class="comment">/*epoll事件类型EPOLLIN EPOLLOUT EPOLLET和EPOLLONESHOT*/</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;<span class="comment">/*存储用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span> &#123;<span class="comment">//可以用来关联用户信息</span></span><br><span class="line">    <span class="type">void</span>* ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">uint32_t</span> u32;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd,<span class="keyword">struct</span> epoll_event* events,<span class="type">int</span> maxevents,<span class="type">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数成功时返回就绪的文件描述符的个数</span></span><br><span class="line"><span class="comment">maxevents参数指定最多监听多少个事件，它必须大于0。</span></span><br><span class="line"><span class="comment">epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>events这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件,极大地提高了应用程序索引就绪文件描述符的效率。</strong></p>
<p>数据发送完毕指的是数据发送到写缓冲区，写缓冲区满的时候才需要注册写事件 ，写事件成功后，需要删掉写事件。</p>
<p>红黑树让 epoll 在查找效率、插入效率、内存开销等等多个方面比较均衡，红黑树的作用是仅仅是在管理大量连接的情况下，添加和删除 socket 非常的高效。如果 epoll 管理的 socket 固定的话，<strong>在数据收发的事件管理过程中其实红黑树是没有起作用的</strong>。内核在socket上收到数据包以后，可以直接找到 epitem(epoll item)，并把它插入到就绪队列里，然后等用户进程把事件取走。这个过程中，红黑树的作用并不会得到体现。</p>
<h3 id="LT水平触发-amp-amp-ET边沿触发"><a href="#LT水平触发-amp-amp-ET边沿触发" class="headerlink" title="LT水平触发&amp;&amp;ET边沿触发"></a>LT水平触发&amp;&amp;ET边沿触发</h3><p>LT模式是默认的工作模式。<br>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程通告此事件，直到该事件被处理。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。<br>ET模式在很大程度上<strong>降低了同 一个epoll事件被重复触发的次数</strong>，因此效率要比LT模式高。<br>每个使用ET模式的文件描述符都应该是<strong>非阻塞的</strong>。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直 处于阻塞状态（饥渴状态）。（一般都需要while一次性将数据全部读完）</p>
<h3 id="EPOLLONESHOT"><a href="#EPOLLONESHOT" class="headerlink" title="EPOLLONESHOT"></a>EPOLLONESHOT</h3><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了<strong>两个线 程同时操作一个socket</strong>的局面。这当然不是我们期望的。我们期望的 是一个socket连接在任一时刻都只被一个线程处理。<br>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数<strong>重置该文件描述符上注册的EPOLLONESHOT事件</strong>。注册了EPOLLONESHOT事件的 socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上 的EPOLLONESHOT事件，以确保这个socket下一次可读时，其 EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个 socket。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>但poll和select存在一个性能缺点就是包含大量文件描述符的<strong>数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪</strong>，它的开销随着文件描述符数量的增加而线性增大。</p>
<p>从实现原理上来说，select和poll采用的都是<strong>轮询</strong>的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是 O（n）。epoll_wait则不同，它采用的是<strong>回调</strong>的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该<strong>就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描 述符集合来检测哪些事件已经就绪</strong>，其算法时间复杂度是O（1）。<br>select，poll轮询的是所有的socket，而epoll只轮询就绪的socket。</p>
<p>select，poll，epoll<strong>本质上都是同步I&#x2F;O</strong>，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>当活动连接比较多的时候，epoll_wait的效率未必比select和poll 高，因为此时回调函数被触发得过于频繁。所以epoll_wait适用于<strong>连接数量多，但活动连接较少</strong>的情况。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" data-id="clh7j8wpl001q2wai589z2kly" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/设计模式/单例模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、懒汉式"><a href="#一、懒汉式" class="headerlink" title="一、懒汉式"></a>一、懒汉式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sigleton</span>(<span class="type">const</span> Sigleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Sigleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Sigleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Sigleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> Sigleton instance_;<span class="comment">//存在性能问题 : 程序会检查是否初始化</span></span><br><span class="line">        <span class="keyword">return</span> instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Sigleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、饿汉式"><a href="#二、饿汉式" class="headerlink" title="二、饿汉式"></a>二、饿汉式</h2><p>c++ 可以保证所有文件内的static变量在main运行开始完成初始化<br>c++ 能保证在同一个文件中声明的static变量的初始换顺序与变量声明的顺序一致<br>但不能保证不同文件中的static变量的初始化顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//other.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;other.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span></span></span><br><span class="line"><span class="function">OtherSingleton&amp;</span></span><br><span class="line"><span class="function"><span class="title">OtherSingleton::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;OtherSingleton GetInstance \n&quot;</span>;</span><br><span class="line"><span class="comment">//    Singleton :: GetInstance();</span></span><br><span class="line">    <span class="keyword">return</span> instance_;</span><br><span class="line">&#125;</span><br><span class="line">OtherSingleton::<span class="built_in">OtherSingleton</span>() &#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;OtherSingleton init \n&quot;</span>;</span><br><span class="line"><span class="comment">//    Singleton :: GetInstance();</span></span><br><span class="line">&#125;</span><br><span class="line">OtherSingleton  OtherSingleton::instance_;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//other.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTEST_OTHER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTEST_OTHER_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OtherSingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OtherSingleton</span>(<span class="type">const</span> OtherSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    OtherSingleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> OtherSingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> OtherSingleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">OtherSingleton</span>();</span><br><span class="line">    <span class="type">static</span> OtherSingleton instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//MYTEST_OTHER_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//singleton.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;other.h&quot;</span></span></span><br><span class="line">Singleton::<span class="built_in">Singleton</span>()&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Singleton init&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    OtherSingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Singleton&amp;</span></span><br><span class="line"><span class="function"><span class="title">Singleton::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;Sigleton&amp; getInstance&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//    OtherSingleton::GetInstance();</span></span><br><span class="line">    <span class="keyword">return</span> instance_;</span><br><span class="line">&#125;</span><br><span class="line">Singleton Singleton::instance_;</span><br><span class="line"><span class="comment">//singleton.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTEST_SINGLETON_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTEST_SINGLETON_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton instance_;</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">//MYTEST_SINGLETON_H</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;singleton.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;other.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;func&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="comment">//    Singleton::GetInstance();</span></span><br><span class="line">    OtherSingleton::<span class="built_in">GetInstance</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Singleton init</span></span><br><span class="line"><span class="comment">OtherSingleton GetInstance</span></span><br><span class="line"><span class="comment">OtherSingleton init</span></span><br><span class="line"><span class="comment">func</span></span><br><span class="line"><span class="comment">OtherSingleton GetInstance</span></span><br><span class="line"><span class="comment">main</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" data-id="clh7j8wpm001r2wai26bh9ilb" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/设计模式/工厂模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>通过“对象创建”模式绕开new，来避免<strong>对象创建过程中的紧耦合（依赖具体类）</strong>，从而支持对象创建的稳定。</p>
<p>new 带来细节依赖</p>
<p>定义一个创建对象的接口，让子类决定实例化哪个类</p>
<p>用于隔离类对象的<strong>使用者</strong>和<strong>具体类型</strong>之间的耦合关系。对于<strong>经常变化的具体类</strong>型，紧耦合使得软件的脆弱</p>
<p>通过面向对象的手法，将所要创建的具体工作延迟到子类，从而实现一种扩展（而非更改代码）的策略</p>
<p> 解决了单个对象的需求变化，缺点在于要求<strong>创建方法&#x2F;参数相同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">filesplitter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">split</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">filesplitter</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">splitterFactory</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> filesplitter* <span class="title">createFactory</span><span class="params">()</span></span>= <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">splitterFactory</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryFilesplitter</span> : <span class="keyword">public</span> filesplitter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;binaryFilesplitter split&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">txtFilesplitter</span> : <span class="keyword">public</span> filesplitter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;txtFilesplitter split&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new binaryFilesplitter(file,number) ;依赖具体 new依赖细节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">binaryFilesplitterFactory</span>: <span class="keyword">public</span> splitterFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">filesplitter * <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">binaryFilesplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">txtFilesplitterFactory</span> : <span class="keyword">public</span> splitterFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">filesplitter * <span class="title">createFactory</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">txtFilesplitter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class A&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void func()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        binaryFilesplitter* fsp = new binaryFilesplitter();//依赖具体类</span></span><br><span class="line"><span class="comment">        fsp-&gt;split();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    splitterFactory *factory;<span class="comment">//工厂   现在没有对具体类的依赖</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">A</span>(splitterFactory *factory_) : <span class="built_in">factory</span>(factory_)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        filesplitter * fsp = factory -&gt; <span class="built_in">createFactory</span>();<span class="comment">//依赖抽象类</span></span><br><span class="line">        fsp-&gt;<span class="built_in">split</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">binaryFilesplitterFactory</span>()).<span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">new</span> <span class="built_in">txtFilesplitterFactory</span>()).<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="clh7j8wpm001s2waiawvq6sni" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/设计模式/观察者模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>通知依赖关系 ： 一个对象的状态发生改变，所有的依赖对象都将得到通知并自动更新</p>
<p>弱化目标对象和观察者对象的依赖关系</p>
<p>可以使得目标和观察者独立的改变，使得依赖关系松耦合</p>
<p>目标发送通知时，通知会自动传播</p>
<p>观察者可以自行订阅通知，目标对象对此一无所知</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSplitter</span><span class="comment">//文件分割器 </span></span><br><span class="line">&#123;</span><br><span class="line">	string m_filePath;</span><br><span class="line">	<span class="type">int</span> m_fileNumber;</span><br><span class="line">	ProgressBar* m_progressBar;<span class="comment">//具体通知控件</span></span><br><span class="line">    <span class="comment">//如果更换通知方式，比如将ProgressBar改成其他类</span></span><br><span class="line">    <span class="comment">//违反依赖倒置原则：编译时依赖</span></span><br><span class="line">    <span class="comment">//不要依赖A ，依赖A的抽象类</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">FileSplitter</span>(<span class="type">const</span> string&amp; filePath, <span class="type">int</span> fileNumber, ProgressBar* progressBar) :</span><br><span class="line">		<span class="built_in">m_filePath</span>(filePath), </span><br><span class="line">		<span class="built_in">m_fileNumber</span>(fileNumber),</span><br><span class="line">		<span class="built_in">m_progressBar</span>(progressBar)&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分割 </span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_fileNumber; i++)&#123;</span><br><span class="line">			<span class="comment">//...</span></span><br><span class="line">			<span class="type">float</span> progressValue = m_fileNumber;</span><br><span class="line">			progressValue = (i + <span class="number">1</span>) / progressValue;</span><br><span class="line">			m_progressBar-&gt;<span class="built_in">setValue</span>(progressValue);<span class="comment">//通知</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subject observer 稳定的</span></span><br><span class="line"><span class="comment">//concreteSubject  concreteObserver 变化的</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span> &#123; <span class="comment">//抽象观察者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Observer</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123; <span class="comment">//抽象目标对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">detach</span><span class="params">(Observer*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">attach</span><span class="params">(Observer*)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//    virtual</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">    vector &lt;Observer*&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Subject::notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> observer:observers) &#123;</span><br><span class="line">        observer -&gt; <span class="built_in">update</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span>:<span class="keyword">public</span> Subject &#123; <span class="comment">//具体目标对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer*)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer* observer)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        observers.<span class="built_in">push_back</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//concreteObserver</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> Observer <span class="comment">//具体观察者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A update()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> Observer &#123;<span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B update()&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ConcreteSubject tmp;</span><br><span class="line">    A a1,a2,a3;B b1,b2;</span><br><span class="line">    tmp.<span class="built_in">attach</span>(&amp;a1);</span><br><span class="line">    tmp.<span class="built_in">attach</span>(&amp;a2);</span><br><span class="line">    tmp.<span class="built_in">attach</span>(&amp;a3);</span><br><span class="line">    tmp.<span class="built_in">attach</span>(&amp;b1);</span><br><span class="line">    tmp.<span class="built_in">attach</span>(&amp;b2);</span><br><span class="line"></span><br><span class="line">    tmp.<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>扩展 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Observer*&gt; observers;</span><br><span class="line">Observer* -&gt; 智能指针 shared_ptr weak_ptr </span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" data-id="clh7j8wpn001t2waigmcj9jx2" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计网/传输层/TCP vs UDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%20vs%20UDP/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>1、基于连接与无连接；</p>
<p>2、对系统资源的要求（TCP较多，UDP少）；</p>
<p>3、UDP程序结构较简单；</p>
<p>4、流模式与数据报模式</p>
<p>5、TCP保证数据正确性，UDP可能丢包；</p>
<p>6、TCP保证数据顺序，UDP不保证。</p>
<p>UDP ：快 ，多对多 ，网络穿透，<strong>无需应答，效率高</strong>，无需在公网中公开IP+端口，一定快吗（UDP不分段，发送大的包，存在丢包问题），关于发送什么数据以及何时发送的应用层控制更精细。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%20vs%20UDP/" data-id="clh7j8wqu00352wai1wdqbphv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计网/传输层/UDP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是<strong>每个 UDP 报文就是一个用户消息的边界</strong>，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
<p>在IPv4网络中，UDP数据报的最大长度为65507字节（65,535 − 8 byte UDP头 − 20 byte IP头）(受到IP数据报的总长度限制·)。</p>
<p>实际上，许多网络设备和操作系统都限制了UDP数据报的大小，因此在编写UDP应用程序时，应该考虑到这些限制。如果UDP数据报太大，它可能会被分成多个IP分组进行传输，这可能会导致数据包的丢失或延迟。</p>
<p>可以用 sudo sysctl net查看 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/UDP/" data-id="clh7j8wqv00362waignf32vv5" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计网/应用层/DHCP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>DHCP 交互中，<strong>全程都是使用 UDP 广播通信</strong></p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>DHCP发现报文 <strong>UDP广播</strong></p>
<p>DHCP提供报文 携带分配好的IP信息</p>
<p>DHCP请求 client 从<strong>多个请求报文</strong>中选一个，进行回显。(一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器)</p>
<p>DHCP ACK </p>
<h2 id="每个网络都要配一个-DHCP-服务器？-DHCP-中继代理"><a href="#每个网络都要配一个-DHCP-服务器？-DHCP-中继代理" class="headerlink" title="每个网络都要配一个 DHCP 服务器？ DHCP 中继代理"></a>每个网络都要配一个 DHCP 服务器？ DHCP 中继代理</h2><ul>
<li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器。</li>
<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给 DHCP 客户端 。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/DHCP/" data-id="clh7j8wqv00372waif2844lxm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计网/应用层/RPC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/RPC/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>远程过程调用</p>
<p>服务发现<br>    http: dns<br>    rpc ： 中间件：redis … </p>
<p>TCP粘包<br>    http  &#x2F;r&#x2F;n   content-length<br>    rpc protobuf &#x3D;&gt; 序列化、反序列化、效率高、不具备自描述能力（JSON)，可读性差</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/RPC/" data-id="clh7j8wqw00382wai5268hyqf" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-note/计网/应用层/http" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/http/" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>get 从服务器获取指定的资源，<strong>请求的资源一般写在URL中</strong><br>post 根据请求负载（报文body）来对指定的资源做出处理</p>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>1XX 提示信息：101切换到websocket<br>2XX 成功 ： 200<br>3XX重定向： 资源发生变动<br>4XX 客户端错误，请求报文有错误，服务器无法处理： 404 not found 请求的资源在服务器上不存在或未找到<br>5XX 服务端错误 ：503 客户端繁忙</p>
<h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><p>​	host 指定服务器的域名 </p>
<p>​	content-length 长度</p>
<p>​	connection 常用于客户端要求服务器使用「HTTP 长连接」机制</p>
<p>​	Content-Type 数据格式</p>
<p>​	Content-Encoding 压缩格式</p>
<p><strong>HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</strong>。</p>
<h2 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h2><p>HTTP 的 Keep-Alive，是由<strong>应用层（用户态）</strong> 实现的，称为 HTTP 长连接；</p>
<p>TCP 的 Keepalive，是由 <strong>TCP 层（内核态）</strong> 实现的，称为 TCP 保活机制；</p>
<p>HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。</p>
<p><strong>HTTP 短连接</strong> ： 建立 TCP -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接</p>
<p>HTTP 的 Keep-Alive 就是实现了这个功能：可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求&#x2F;应答，避免了连接建立和释放的开销</p>
<p>HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且这给 <strong>HTTP 流水线</strong>技术提供了可实现的基础。</p>
<p>所谓的 HTTP 流水线，是<strong>客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的回应</strong>，可以减少整体的响应时间。但是<strong>服务器必须按照接收请求的顺序发送对这些管道化请求的响应</strong></p>
<p>TCP 的 Keepalive 这东西其实就是 <strong>TCP 的保活机制</strong></p>
<p>如果对端主机宕机（<em>注意不是进程崩溃，进程崩溃后操作系统在回收进程资源的时候，会发送 FIN 报文，而主机宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机</em>），或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong></p>
<p>TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的</p>
<h2 id="https-x3D-http-加密-认证-完整性保护"><a href="#https-x3D-http-加密-认证-完整性保护" class="headerlink" title="https &#x3D; http +  加密 +  认证  + 完整性保护"></a>https &#x3D; http +  加密 +  认证  + 完整性保护</h2><p>http 明文传输</p>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>共享密钥加密： 使用同一个密钥 不安全 </p>
<p>公开密钥加密：公钥+私钥  慢 安全</p>
<p>​公钥加密，私钥解密。这个目的是为了保证<strong>内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；</p>
<p>​私钥加密，公钥解密。这个目的是为了保证消息不会被<strong>冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。</p>
<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>https 混合加密 ：把共享密钥用公开密钥加密，之后用共享密钥进行通信 </p>
<p>如何拿到正确的服务器公钥，而不是伪造的：CA </p>
<h3 id="RSA四次握手"><a href="#RSA四次握手" class="headerlink" title="RSA四次握手"></a>RSA四次握手</h3><p>client 发送随机数 </p>
<p>server发送随机数 + 数字证书（ca用自己的私钥对server的公钥进行加密）</p>
<p>client 用ca的公钥解密，确定是server ，得到服务器的公钥，然后生成随机数，用公钥加密，发给server</p>
<p>三个随机数生成会话密钥，双方之后用此会话密钥进行通信，然后交换所有握手数据的摘要。</p>
<p>完整性保护：将消息分割、压缩，加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证。之后一起经过加密。</p>
<p>使用 RSA 密钥协商算法的最大问题是不支持前向保密。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/03/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/http/" data-id="clh7j8wqw00392waihirreprk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/03/note/linux/awk/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/03/note/linux/fork/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/03/note/linux/free/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/03/note/linux/gdb/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/03/note/linux/%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 daidai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
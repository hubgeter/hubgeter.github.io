<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>daidai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="daidai">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="daidai">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="daidai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="daidai" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">daidai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-os/wait" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/3113d9687d61.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程不可运行并处于EXIT_ZOMBIE状态，占有的所有内存就是<strong>内核栈、thread_info 、task_struct</strong>结构</p>
<p>进程存在的唯一目的是：<strong>向他的父进程提供信息</strong>。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。</p>
<p>仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
<p>实际上当子进程终止时，内核就会向它的父进程发送一个<em>SIGCHLD</em>信号，父进程可以选择忽略该信号，也可以提供一个接收到信号以后的处理函数。对于这种信号的系统默认动作是忽略它。我们不希望有过多的僵尸进程产生，所以当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。</p>
<p>孤儿进程将被在当前进程组中找一个线程作为父亲、如果不行则让<em>init</em>做父进程所收养，并由新的父进程对它们完成状态收集工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/3113d9687d61.html" data-id="clh7k3uy8001qeqai2gylbd5s" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/中断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/fdec8e4e7767.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="硬件中断和软件中断（Software-Interrupt）"><a href="#硬件中断和软件中断（Software-Interrupt）" class="headerlink" title="硬件中断和软件中断（Software Interrupt）"></a>硬件中断和软件中断（Software Interrupt）</h2><h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件中断是由<em>硬件设备</em>产生的中断信号，例如键盘输入、鼠标移动、网络数据包到达等。当硬件设备产生中断信号时，CPU会立即停止当前的工作，转而执行中断处理程序。中断处理程序通常是由操作系统内核提供的，它可以对中断进行处理，例如读取键盘输入、发送网络数据包等。硬件中断是一种异步的事件，它可以在任何时候发生，因此操作系统必须能够及时响应中断请求，以保证系统的性能和可靠性。</p>
<h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>软件中断是由软件产生的中断信号，例如<em>系统调用、信号</em>等。当软件产生中断信号时，CPU会立即停止当前的工作，转而执行中断处理程序。软件中断通常是由用户进程发起的，它可以用于进程之间的同步和通信。软件中断是一种同步的事件，它只有在特定的条件下才会发生，因此操作系统可以更加灵活地处理软件中断请求。<strong>int 0x80 &#x2F;  ecall</strong></p>
<h2 id="中断的上下部"><a href="#中断的上下部" class="headerlink" title="中断的上下部"></a>中断的上下部</h2><p>希望尽量减少中断处理程序中的工作量，因为其<em>运行时会屏蔽中断</em></p>
<p>中断+其他程序<em>异步执行</em><br>下半部分：执行与中断处理密切相关，但中断处理程序本身不执行的工作</p>
<p><strong>软中断</strong>(softIRQ)，即中断下半部机制。ISR运行时间不易过长，linux将中断中的一部分逻辑推后执行，这就是softIRQ，它完全由软件实现</p>
<p>对于网卡来说，如果每次网卡收包时中断的时间都过长，那很可能造成丢包的可能性。当然我们不能完全避免丢包的可能性，以太包的传输是没有100%保证的，所以网络才有协议栈，通过高层的协议来保证连续数据传输的数据完整性（比如在协议发现丢包时要求重传）。但是即使有协议保证，那我们也不能肆无忌惮的使用中断，中断的时间越短越好，尽快放开处理器，让它可以去响应下次中断甚至进行调度工作。基于这样的考虑，我们将中断分成了上下两部分，上半部分就是上面说的中断部分，需要快速及时响应，同时需要越快结束越好。而下半部分就是完成一些可以推后执行的工作。对于网卡收包来说，网卡收到数据包，通知内核数据包到了，中断处理将数据包存入内存这些都是急切需要完成的工作，放到上半部完成。而解析处理数据包的工作则可以放到下半部去执行</p>
<p>软中断就是下半部使用的一种机制，它通过软件模仿硬件中断的处理过程，但是和硬件没有关系，单纯的通过软件达到一种异步处理的方式。其它下半部的处理机制还包括tasklet，工作队列等。依据所处理的场合不同，选择不同的机制，网卡收包一般使用软中断。</p>
<p>中断处理的下半部是指中断处理程序的退出部分之后，CPU返回到原来的执行环境，继续执行被中断的进程。在中断处理的下半部中，可以<em>执行一些比较耗时的操作</em>，例如访问文件系统、发送网络数据包等。由于中断处理程序需要尽可能地快速执行，因此它们通常只完成必要的操作，而将一些比较耗时的操作放到中断处理的下半部中执行。在Linux中，中断处理的下半部通常由两种机制来实现：软中断和tasklet。软中断是一种在内核中运行的软件例程，可以被用户进程调用。tasklet是一种轻量级的中断处理机制，它可以在中断上下文中运行，但是不会被硬件中断打断。软中断和tasklet都可以用于中断处理的下半部，以提高系统的性能和可靠性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/fdec8e4e7767.html" data-id="clh7k3uy9001teqai14nvea0w" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/信号" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/8c522f982e4b.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>信号是软件中断</p>
<p>信号提供了一种异步处理事件的方法，产生信号的进程对于时间来说是随机的</p>
<p>早期不可靠的信号 ： 在进程不希望某种信号发生时，他不能关闭信号，只能忽略</p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="忽略此信号：-SIG-IGN"><a href="#忽略此信号：-SIG-IGN" class="headerlink" title="忽略此信号： SIG_IGN"></a>忽略此信号： SIG_IGN</h3><h3 id="捕捉信号：-注册-x2F-调用用户函数"><a href="#捕捉信号：-注册-x2F-调用用户函数" class="headerlink" title="捕捉信号： 注册&#x2F;调用用户函数"></a>捕捉信号： 注册&#x2F;调用用户函数</h3><h3 id="执行系统默认动作：-SIG-DFL"><a href="#执行系统默认动作：-SIG-DFL" class="headerlink" title="执行系统默认动作： SIG_DFL"></a>执行系统默认动作： SIG_DFL</h3><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>不能忽略&#x2F;捕获 SIGKILL 和 SIGSTOP ，它们向内核和操作系统提供使进程终止和停止的可靠方法</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ctrl+c\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Signal %d(MISSING) handler.\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, handler);<span class="comment">//func = SIG_IGN/handler/SIG_DFL</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program is running...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill命令默认的信号就是15，也就是 kill -15,被称为优雅的退出。</p>
<p>当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p>
<p>kill -9就相对强硬一点，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/8c522f982e4b.html" data-id="clh7k3uy9001veqai1037a9fk" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/动态链接" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/001ac49a4d2b.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>用动态链接方法将程序与共享库函数链接：减少可执行文件的长度、库函数的新版本替代老版本无需对该库的程序重新链接</p>
<p>装载时重定位：模块装载地址确定，程序对绝对地址引用重定位。但，动态链接模块lib2.so被装载映射后，指令部分是共享的，修改之后无法共享，因为在不同的进程中动态链接模块lib1.so加载地址不同。</p>
<p>地址无关代码：<br>​	模块内部调用&#x2F;数据：不用重定位<br>​	模块数据间：在数据段（数据段不共享）中建立全局偏移表<em>GOT</em>（指向变量的指针数组），GOT在模块装载时进行修改（GOT与当前代码段的偏移是固定的）</p>
<p>延迟绑定：第一次用的时候才进行绑定</p>
<p>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/001ac49a4d2b.html" data-id="clh7k3uyd001yeqaiccmudt7w" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/4f763e682e64.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="malloc-分配虚拟内存-，真正用的时候会发生缺页中断"><a href="#malloc-分配虚拟内存-，真正用的时候会发生缺页中断" class="headerlink" title="malloc : 分配虚拟内存 ，真正用的时候会发生缺页中断"></a>malloc : 分配虚拟内存 ，真正用的时候会发生缺页中断</h2><p>大多数实现所分配的存储空间要稍大一些，额外的空间用来记录管理信息</p>
<h3 id="申请空间-lt-128k"><a href="#申请空间-lt-128k" class="headerlink" title="申请空间 &lt; 128k"></a>申请空间 &lt; 128k</h3><p>sbrk 系统调用：扩充、减少进程的堆</p>
<p>大多数malloc free 的实现都不减小进程的存储空间，将释放的空间<em>保持在malloc 池中</em>而不返回给内核</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//cat /proc/pid/maps</span></span><br><span class="line"><span class="comment">//555cbac37000-555cbac58000 rw-p 00000000 00:00 0   [heap] </span></span><br><span class="line">    <span class="type">int</span> x; cin &gt;&gt; x;<span class="comment">//50 </span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">void</span>*&gt; <span class="title">v</span><span class="params">(x*<span class="number">1e5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        v[i] = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]</span></span><br><span class="line">    <span class="type">int</span> y;cin &gt;&gt; y ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        <span class="comment">// malloc(10);</span></span><br><span class="line">        <span class="built_in">free</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]</span></span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        v[i] = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]    </span></span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="申请空间-gt-x3D-128k"><a href="#申请空间-gt-x3D-128k" class="headerlink" title="申请空间 &gt;&#x3D; 128k"></a>申请空间 &gt;&#x3D; 128k</h3><p>使用mmap的方式申请内存，mmap 以<em>匿名映射</em>的方式从文件映射区分配的匿名内存，free的时候会把内存归还给os</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741c4000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;cin &gt;&gt; x;</span><br><span class="line">    <span class="type">void</span> * p1 = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);<span class="comment">//12&amp;*1024</span></span><br><span class="line">    cout&lt;&lt;p1 &lt;&lt; endl;<span class="comment">// 0x7fc7741a3010</span></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741a3000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);<span class="comment">//12&amp;*1024</span></span><br><span class="line">    cout&lt;&lt;p2 &lt;&lt; endl;<span class="comment">// 0x7fc774182010</span></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc774182000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">free</span>(p1);<span class="built_in">free</span>(p2);</span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741c4000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/4f763e682e64.html" data-id="clh7k3uyf0020eqai2i0o2dq4" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/栈" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/6acf429620d8.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="调用惯例"><a href="#调用惯例" class="headerlink" title="调用惯例"></a>调用惯例</h2><ol>
<li>函数参数的传递顺序和方式</li>
<li>栈的维护方式：栈中的参数弹出</li>
<li>名字修饰的策略</li>
</ol>
<h2 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h2><ol>
<li>参数压栈</li>
</ol>
<p>call : </p>
<ol start="2">
<li>当前地址的下一条指令地址压栈（返回地址）</li>
<li>跳转到函数体执行，函数体开头如下：</li>
<li>push ebp ( old ebp )</li>
<li>mov ebp.esp ( esp &#x3D; ebp)</li>
<li>保存寄存器</li>
</ol>
<h2 id="栈的大小"><a href="#栈的大小" class="headerlink" title="栈的大小"></a>栈的大小</h2><p>栈不会自动扩容 </p>
<p>ulimit -a 查看栈的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        cout&lt;&lt;x &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x;cin &gt;&gt; x;<span class="comment">// 209</span></span><br><span class="line">        <span class="built_in">dfs</span>(x);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">void</span> * p = <span class="built_in">alloca</span>( <span class="number">1024</span> * <span class="number">8</span>*<span class="number">104</span> );<span class="comment">//在当前函数的栈帧上分配空间、而不是在堆中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="setjmp-longjmp"><a href="#setjmp-longjmp" class="headerlink" title="setjmp longjmp"></a>setjmp longjmp</h2><p>goto语句不能跨越函数</p>
<p>可以在栈上跳过若干调用帧，返回到当前函数<em>调用路径上的某个函数</em>中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">jmp_buf jmpbuffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;start func2\n&quot;</span>;</span><br><span class="line">    <span class="built_in">longjmp</span>(jmpbuffer, <span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end func2\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;start func1\n&quot;</span>;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end func1\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">setjmp</span>(jmpbuffer);<span class="comment">//编译优化后，会对自动变量有影响</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;val = &quot;</span>&lt;&lt;val&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> ( val == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;main end\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/6acf429620d8.html" data-id="clh7k3uyg0023eqaiayfl1y5f" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/系统调用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/26b4e9560fea.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h2><p>用户态： printf() 标准库函数 </p>
<p>用户态：write() 封装函数 -&gt; 设置寄存器的值 -&gt; INT $0x80</p>
<p>内核态： system_call() 系统调用处理函数，根据寄存器中的系统调用号进行跳转</p>
<p>内核态：sys_write() 系统调用服务例程</p>
<h2 id="标准io库函数与系统调用封装函数"><a href="#标准io库函数与系统调用封装函数" class="headerlink" title="标准io库函数与系统调用封装函数"></a>标准io库函数与系统调用封装函数</h2><h3 id="标准io库函数-fopen-fread-printf-scanf"><a href="#标准io库函数-fopen-fread-printf-scanf" class="headerlink" title="标准io库函数: fopen(), fread() ,  printf() , scanf()"></a>标准io库函数: fopen(), fread() ,  printf() , scanf()</h3><ol>
<li><p>具有更好的<em>移植性</em></p>
</li>
<li><p>使用在内存中的<em>缓冲区</em>，使得系统调用和io次数减少 </p>
</li>
<li><p>c语言标准库的不足 ：所有IO操作都是<em>同步的</em>；不提供读取文件元数据（文件的属性信息）的函数；进行网络编程容易造成缓冲区溢出；<em>不对文件提供加锁、解锁;</em> 并没有覆盖所有底层操作系统提供的功能。</p>
</li>
<li><p>使用C标准库进行网络编程容易造成<em>缓冲区溢出</em>的原因是因为C标准库中的函数没有对缓冲区的大小进行检查，而且C标准库中的函数通常是使用缓冲区的长度作为参数，而不是缓冲区的指针。这意味着如果缓冲区的长度小于实际数据的长度，那么数据将会溢出到缓冲区之外，从而导致缓冲区溢出。为了避免这种情况，应该使用更安全的函数，如使用C++标准库或使用第三方库，如Boost或Qt。如果必须使用C标准库，应该使用带有缓冲区大小参数的函数，如fgets和snprintf，以确保缓冲区不会溢出。</p>
</li>
</ol>
<h3 id="系统调用封装函数：open-read-write-stat-close"><a href="#系统调用封装函数：open-read-write-stat-close" class="headerlink" title="系统调用封装函数：open() ,read() ,write() stat(), close()"></a>系统调用封装函数：open() ,read() ,write() stat(), close()</h3><p>对文件的标识是<em>文件描述符fd</em>,而c标准库函数中对文件的标识是指向FILE结构的指针的fd</p>
<p>​    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/26b4e9560fea.html" data-id="clh7k3uyh0025eqaifrrd2vbj" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/虚拟内存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/e0a8c9fe2865.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>操作系统通过内存管理单元（MMU）将物理内存划分为若干个大小相等的<strong>页框</strong>，每个页框的大小通常为4KB或者2MB。操作系统通过页表将虚拟地址映射到物理地址，从而实现内存的分配和管理。</p>
<p>当进程需要分配内存时，操作系统会从空闲的页框中选择一个或多个页框分配给该进程，同时更新<em>页表</em>中的映射关系。内存分配的具体实现方式包括伙伴系统、slab分配器等。内核空间的内存分配通常使用伙伴系统，用户空间的内存分配通常使用slab分配器。</p>
<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>内核<br>文件映射&#x2F;动态链接库&#x2F;匿名映射<br>堆<br>.data .bss 数据段<br>.init .rodata 代码段</p>
<h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><ol>
<li><p>最佳页面置换算法基本思路是，<strong>置换在「未来」最长时间不访问的页面</strong></p>
</li>
<li><p>先进先出置换算法（<em>FIFO</em>）</p>
</li>
<li><p>最近最久未使用的置换算法（<em>LRU</em>）</p>
</li>
<li><p>最不常用置换算法（<em>LFU</em>）</p>
</li>
<li><p>时钟页面置换算法（<em>Lock</em>） : 把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面 ; 如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；</p>
</li>
</ol>
<h2 id="内存不足"><a href="#内存不足" class="headerlink" title="内存不足"></a>内存不足</h2><p>缺页中断  &#x3D;&gt;  找空闲的物理内存 &#x3D;&gt;  <em>没有</em> &#x3D;&gt; 回收内存</p>
<ol>
<li><p>后台内存回收 异步 </p>
</li>
<li><p>直接内存回收 <em>同步</em> 会阻塞进程的执行</p>
</li>
<li><p><strong>OOM</strong> 选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源</p>
</li>
</ol>
<p>哪些内存可以被回收</p>
<p>基于LRU&#x2F;2算法<br>    - 文件页：回写<br>    - 匿名页：swap()机制</p>
<p><strong>脏页回写的情况：空闲内存不足，驻留时间长，用户sync&#x2F;fsnc系统调用</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/e0a8c9fe2865.html" data-id="clh7k3uyi0028eqai36my03ss" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/进程 线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/d7983b37fa37.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程控制块 PCB 是进程存在的唯一标识</p>
<p>进程提供两种抽象 ：虚拟处理器、虚拟内存</p>
<p>Linux 用<strong>task_struct</strong>表示PCB；在内核栈的尾部创建thread_info，通过计算偏移间接地查找task_struct  </p>
<p><strong>task_struct</strong>：进程状态、内存地址空间、打开的文件、挂起的信号、内核内部数据、处理器状态、一个&#x2F;多个执行线程</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
<p>只具备必不可缺地资源：堆栈 寄存器。</p>
<p>linux中线程被视为一个与其他进程共享某些资源的进程    </p>
<p>用户线程 </p>
<p>内核线程  独立运行在内核空间的标准进程</p>
<h3 id="多线程一定比单线程好么？"><a href="#多线程一定比单线程好么？" class="headerlink" title="多线程一定比单线程好么？"></a>多线程一定比单线程好么？</h3><p>不一定，因为多线程的上下文切换和线程创建所带来的开销会带来一定的消耗</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><ul>
<li>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换（保存当前状态到PCB，加载新的PCB）一样；</li>
<li><strong>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</strong>；</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>FIFO </p>
<p>最短作业 </p>
<p>优先级调度 </p>
<p>轮转调度 </p>
<p>多级反馈队列（在较低级等待队列中等待过长的进程会被放入较高优先级等待队列）  </p>
<h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ol>
<li>进程是<em>资源（包括内存、打开的文件等）分配</em>的单位，线程是 <em>CPU 调度</em>的单位；</li>
<li>进程拥有一个完整的资源平台，而线程只<em>独享必不可少的资源</em>，如寄存器和栈；</li>
<li>线程的<em>创建和销毁</em>比进程快得多，线程之间的<em>切换</em>也比进程快得多(同一个进程的线程都具有同一个页表)。另外，由于线程共享进程的地址空间，因此线程之间的<em>通信</em>比进程之间的通信更加方便快捷。但是，由于线程共享进程的地址空间，因此线程之间的同步和互斥需要特殊的机制来保证。由于同一进程的各线程间共享内存和文件等系统资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；</li>
<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；</li>
<li>一个<em>线程异常</em>，会影响到同一进程的其他线程；而进程不会</li>
</ol>
<h2 id="进程与线程的选择"><a href="#进程与线程的选择" class="headerlink" title="进程与线程的选择"></a>进程与线程的选择</h2><ol>
<li><p>需要<strong>频繁创建销毁</strong>的优先使用线程。一次网络请求，一次数据库查询等。线程多见于web服务器、数据库服务器、文件服务器、邮件服务器等中。来一个建立一个线程，断了就销毁线程。</p>
</li>
<li><p><em>强相关</em>处理用线程，弱相关处理用进程。</p>
</li>
<li><p>需要进行<em>大量的计算</em>优先使用线程</p>
</li>
<li><p><strong>可能要扩展到多机分布的用进程，多核分布的用线程</strong></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/d7983b37fa37.html" data-id="clh7k3uym002aeqaihd9j4b4u" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/3155c667d469.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁则是一种忙等锁，它会在等待锁的过程中不断自旋，检查锁是否已经被释放。如果锁已经被释放，自旋锁会立即占用该锁并继续执行。如果锁仍然被占用，自旋锁会一直自旋，直到获取到锁为止。</p>
<p>自旋锁适用于共<em>享资源的竞争不激烈</em>的情况，因为它<strong>不会引起线程的上下文切换</strong>，从而提高了效率。但是如果共享资源的竞争激烈，自旋锁会导致大量的浪费时间在自旋上，降低系统的性能。</p>
<p>如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 OS(Operating System) 调度程序中断的风险越大。如果发生中断情况，那么其他线程将保持旋转状态(反复尝试获取锁)，而持有该锁的线程并不释放锁，这样导致的是结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SpinLock</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (flag.<span class="built_in">test_and_set</span>())&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        flag.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    atomic_flag flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="互斥锁-条件变量"><a href="#互斥锁-条件变量" class="headerlink" title="互斥锁+条件变量"></a>互斥锁+条件变量</h3><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的实现原理通常使用<strong>版本号或时间戳</strong>。在访问共享资源之前，每个线程都会从共享资源中读取一个版本号或时间戳，并在修改共享资源时使用它。当线程完成修改并准备释放共享资源时，它会将版本号或时间戳递增，并将其写回共享资源。如果在此过程中，另一个线程同时修改了该共享资源，那么在写回版本号或时间戳时，该线程将会检测到冲突，并且需要执行一些特殊的处理，例如重试操作或回滚操作。</p>
<p>乐观锁的实现原理相对于互斥锁来说更加轻量级，因为它不需要显式地阻塞线程。然而，在高并发的情况下，乐观锁可能会频繁地出现冲突，从而导致性能下降。因此，在使用乐观锁时，需要对共享资源的访问进行合理的控制和调度，以避免冲突和性能问题。</p>
<p>ABA 问题:一个变量第一次读取的值是 A，准备好需要对 A 进行写操作的时候，发现值还是 A，那么这种情况下，能认为 A 的值没有被改变过吗？+ version </p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁预防：只要一个不成立，就能预防死锁</p>
<ul>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>持有并等待：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>无抢占：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ul>
<p>死锁避免 ： 银行家算法</p>
<p>资源有序分配法来破坏环路等待条件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/3155c667d469.html" data-id="clh7k3uyn002deqaidh1d5tpp" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/">cpp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/c-11/">c++11</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/class/">class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/stl/">stl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/template/">template</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/waining/">waining</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">语言相关</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/os/">os</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/">计网</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/">TCP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/e4241cb5f901.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/688307dd2a74.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/3100c0d60cf1.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/6e0ab8664bab.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/1ed1cddfd6c6.html">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 daidai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
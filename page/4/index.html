<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>daidai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="daidai">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="daidai">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="daidai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="daidai" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">daidai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-os/fork" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/d8db15e830dd.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/d8db15e830dd.html">fork</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>用于创建一个新进程，子进程是父进程的副本，它继承了父进程的所有数据和代码段。子进程和父进程共享相同的代码段，但是拥有独立的数据段和堆栈，它们<strong>运行时是完全独立</strong>的。</p>
<p>fork 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h2><p>vfork() 是 fork() 的一种变体，它不会像 fork() 一样复制父进程的地址空间，而是<strong>共享</strong>父进程的地址空间。这意味着子进程将共享父进程的代码段、数据段和堆栈。</p>
<p>vfork 除了不拷贝父进程的页表项 ，其余与fork功能相同。 	</p>
<p>vfork()保证<strong>子进程先运行</strong>，在她调用exec或_exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。因此vfork设计用以子进程创建后立即执行execve系统调用加载新程序的情形。在子进程退出或开始新程序之前，内核保证了父进程处于阻塞状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VFORK|CLONE_VM|SIGCHLD,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>


<h2 id="pthread-线程"><a href="#pthread-线程" class="headerlink" title="pthread 线程"></a>pthread 线程</h2><p>在 pthread 库中，创建<strong>线程</strong>时调用的是 clone 系统调用，其参数包括：</p>
<ol>
<li>start_routine：新线程要执行的函数指针；</li>
<li>arg：start_routine 函数的参数；</li>
<li>child_stack：指向新线程的栈空间的指针；</li>
<li>flags：用于控制新线程的行为，可以设置以下标志：</li>
</ol>
<ul>
<li>CLONE_VM：新线程与原线程共享地址空间；</li>
<li>CLONE_FS：新线程与原线程共享文件系统信息；</li>
<li>CLONE_FILES：新线程与原线程共享文件描述符表；</li>
<li>CLONE_SIGHAND：新线程与原线程共享信号处理程序；</li>
<li>CLONE_THREAD：创建线程而非进程；</li>
<li>CLONE_SYSVSEM：新线程与原线程共享 System V 信号量；</li>
<li>CLONE_SETTLS：为新线程设置 TLS（Thread Local Storage）。</li>
</ul>
<p>注意：在 pthread 库中，实际上是通过封装 clone 系统调用来实现线程的创建和管理的，并且传递给 clone 系统调用的参数也有所不同。</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p>它可以用来创建一个新的<strong>进程或线程</strong>。</p>
<p>clone() 可以控制新进程与父进程之间的共享资源，而且可以指定子进程的资源和行为。它也可以创建轻量级线程，会共享父进程的地址空间，但是拥有独立的执行流。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>fork() 和 vfork() 创建的进程都是完全独立的进程，它们都会复制父进程的地址空间，但是 vfork() 在子进程创建新的地址空间前会暂停父进程的执行。而 clone() 可以控制新进程与父进程之间的共享资源，它更加灵活。</p>
<p>fork()，vfork()， __clone() 库函数都会根据需要的参数标志去调用clone() ，clone() 去调用do_fork()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">do_fork()</span><br><span class="line">&#123;</span><br><span class="line">    copy_process();</span><br><span class="line">&#125;</span><br><span class="line">copy_process()</span><br><span class="line">&#123;</span><br><span class="line">    copy_mm()</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子进程虚拟内存空间，父进程虚拟内存空间</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        ...... 省略 ......</span><br><span class="line"></span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取父进程虚拟内存空间</span></span><br><span class="line">	oldmm = current-&gt;mm;</span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ...... 省略 ......</span><br><span class="line">    <span class="comment">// 通过 vfork 或者 clone 系统调用创建出的子进程（线程）和父进程共享虚拟内存空间</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        <span class="comment">// 增加父进程虚拟地址空间的引用计数</span></span><br><span class="line">		mmget(oldmm);</span><br><span class="line">        <span class="comment">// 直接将父进程的虚拟内存空间赋值给子进程（线程）</span></span><br><span class="line">        <span class="comment">// 线程共享其所属进程的虚拟内存空间</span></span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">    <span class="comment">// 如果是 fork 系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的 mm_struct 结构中。</span></span><br><span class="line">	mm = dup_mm(tsk);</span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">    <span class="comment">// 将拷贝出来的父进程虚拟内存空间 mm_struct 赋值给子进程</span></span><br><span class="line">	tsk-&gt;mm = mm;</span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/d8db15e830dd.html" data-id="clhh55tu5001q6caiahsbezc9" data-title="fork" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/ipc" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/edd4678f105a.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/edd4678f105a.html">ipc</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程有不同的用户地址空间，所以进程通信需要<strong>通过内核</strong></p>
<ol>
<li><p>管道 ： 只能单向通信，只能用于具有亲缘关系的进程间通信</p>
</li>
<li><p>命名管道fifo ： 一种文件类型  mkfifo + open + read 非线性连接  没关系的进程间通信<br>​					有PIPE_BUF常量，表示可被原子写到FIFO的最大数据量</p>
</li>
<li><p>信号 ：  信号是进程间通信机制中<strong>唯一的异步通信机制</strong><br>​	用户进程对信号的处理方式 ： 默认方式，捕捉信号，忽略。</p>
</li>
<li><p>消息队列 ：唯一的消息队列标识符 ，可以实现消息的随机查询 msgget + msgsnd + msgctl +msgrcv   消息队列是保存在内核中的消息链表   消息队列通信过程中，<strong>存在用户态与内核态之间的数据拷贝开销</strong></p>
</li>
<li><p>共享内存：进程间共享数据<strong>最快，效率最高</strong>的方式 shmget + shmat + shmdt + shmctl</p>
</li>
<li><p>信号量：保护共享资源 </p>
</li>
<li><p><strong>socket</strong></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/edd4678f105a.html" data-id="clhh55tu6001s6caigvztaya4" data-title="ipc" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/mmap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/be4aef5d762c.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/be4aef5d762c.html">mmap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>内存映射文件</strong>的机制，通过将文件的一部分或全部映射到进程的虚拟内存中，使得该文件的内容可以像普通内存一样被访问，从而提高了文件读写的效率。<br>加载<strong>动态链接库</strong></p>
<p>实现进程间<strong>共享内存</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/be4aef5d762c.html" data-id="clhh55tu8001v6cai3yp8d0sf" data-title="mmap" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/tmp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/9d618e4c6d7c.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/9d618e4c6d7c.html">tmp</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>如果一个多线程程序的某个线程调用了fork 函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程 呢？答案是“否”，正如我们期望的那样。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动<strong>继承父进程中互斥锁（条件变量与之类似）的状态</strong>。也就是说，父进程中已 经被加锁的互斥锁在子进程中也是被锁住的。这就引起了一个问题： 子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork 函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况， 则子进程若再次对该互斥锁执行加锁操作就会导致死锁 &#x3D;&#x3D; &gt; pthread_atfork</p>
<p><img src="/../images/os/tmp/image-20230502174856759.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/9d618e4c6d7c.html" data-id="clhh55tua001x6cai2wyi7xyc" data-title="tmp" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/wait" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/f1b77c412ffc.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/f1b77c412ffc.html">wait</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>进程不可运行并处于EXIT_ZOMBIE状态，占有的所有内存就是<strong>内核栈、thread_info 、task_struct</strong>结构</p>
<p>进程存在的唯一目的是：<strong>向他的父进程提供信息</strong>。</p>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程。</p>
<p>仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。</p>
<p>实际上当子进程终止时，内核就会向它的父进程发送一个<em>SIGCHLD</em>信号，父进程可以选择忽略该信号，也可以提供一个接收到信号以后的处理函数。对于这种信号的系统默认动作是忽略它。我们不希望有过多的僵尸进程产生，所以当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。</p>
<h2 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h2><p>一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。</p>
<p>孤儿进程将被在当前进程组中找一个线程作为父亲、如果不行则让<em>init</em>做父进程所收养，并由新的父进程对它们完成状态收集工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/f1b77c412ffc.html" data-id="clhh55tub00206caid2npdv0e" data-title="wait" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/中断" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/b6027bb02032.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/b6027bb02032.html">中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="硬件中断和软件中断（Software-Interrupt）"><a href="#硬件中断和软件中断（Software-Interrupt）" class="headerlink" title="硬件中断和软件中断（Software Interrupt）"></a>硬件中断和软件中断（Software Interrupt）</h2><h3 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h3><p>硬件中断是由<em>硬件设备</em>产生的中断信号，例如键盘输入、鼠标移动、网络数据包到达等。当硬件设备产生中断信号时，CPU会立即停止当前的工作，转而执行中断处理程序。中断处理程序通常是由操作系统内核提供的，它可以对中断进行处理，例如读取键盘输入、发送网络数据包等。硬件中断是一种异步的事件，它可以在任何时候发生，因此操作系统必须能够及时响应中断请求，以保证系统的性能和可靠性。</p>
<h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3><p>软件中断是由软件产生的中断信号，例如<em>系统调用、信号</em>等。当软件产生中断信号时，CPU会立即停止当前的工作，转而执行中断处理程序。软件中断通常是由用户进程发起的，它可以用于进程之间的同步和通信。软件中断是一种同步的事件，它只有在特定的条件下才会发生，因此操作系统可以更加灵活地处理软件中断请求。<strong>int 0x80 &#x2F;  ecall</strong></p>
<h2 id="中断的上下部"><a href="#中断的上下部" class="headerlink" title="中断的上下部"></a>中断的上下部</h2><p>希望尽量减少中断处理程序中的工作量，因为其<em>运行时会屏蔽中断</em></p>
<p>中断+其他程序<em>异步执行</em><br>下半部分：执行与中断处理密切相关，但中断处理程序本身不执行的工作</p>
<p><strong>软中断</strong>(softIRQ)，即中断下半部机制。ISR运行时间不易过长，linux将中断中的一部分逻辑推后执行，这就是softIRQ，它完全由软件实现</p>
<p>对于网卡来说，如果每次网卡收包时中断的时间都过长，那很可能造成丢包的可能性。当然我们不能完全避免丢包的可能性，以太包的传输是没有100%保证的，所以网络才有协议栈，通过高层的协议来保证连续数据传输的数据完整性（比如在协议发现丢包时要求重传）。但是即使有协议保证，那我们也不能肆无忌惮的使用中断，中断的时间越短越好，尽快放开处理器，让它可以去响应下次中断甚至进行调度工作。基于这样的考虑，我们将中断分成了上下两部分，上半部分就是上面说的中断部分，需要快速及时响应，同时需要越快结束越好。而下半部分就是完成一些可以推后执行的工作。对于网卡收包来说，网卡收到数据包，通知内核数据包到了，中断处理将数据包存入内存这些都是急切需要完成的工作，放到上半部完成。而解析处理数据包的工作则可以放到下半部去执行</p>
<p>软中断就是下半部使用的一种机制，它通过软件模仿硬件中断的处理过程，但是和硬件没有关系，单纯的通过软件达到一种异步处理的方式。其它下半部的处理机制还包括tasklet，工作队列等。依据所处理的场合不同，选择不同的机制，网卡收包一般使用软中断。</p>
<p>中断处理的下半部是指中断处理程序的退出部分之后，CPU返回到原来的执行环境，继续执行被中断的进程。在中断处理的下半部中，可以<em>执行一些比较耗时的操作</em>，例如访问文件系统、发送网络数据包等。由于中断处理程序需要尽可能地快速执行，因此它们通常只完成必要的操作，而将一些比较耗时的操作放到中断处理的下半部中执行。在Linux中，中断处理的下半部通常由两种机制来实现：软中断和tasklet。软中断是一种在内核中运行的软件例程，可以被用户进程调用。tasklet是一种轻量级的中断处理机制，它可以在中断上下文中运行，但是不会被硬件中断打断。软中断和tasklet都可以用于中断处理的下半部，以提高系统的性能和可靠性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/b6027bb02032.html" data-id="clhh55tuc00226caic8nnd01l" data-title="中断" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/信号" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/46d8db601c78.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/46d8db601c78.html">信号</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>信号是软件中断</p>
<p>信号提供了一种异步处理事件的方法，产生信号的进程对于时间来说是随机的</p>
<p>早期不可靠的信号 ： 在进程不希望某种信号发生时，他不能关闭信号，只能忽略</p>
<h2 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h2><h3 id="忽略此信号：-SIG-IGN"><a href="#忽略此信号：-SIG-IGN" class="headerlink" title="忽略此信号： SIG_IGN"></a>忽略此信号： SIG_IGN</h3><h3 id="捕捉信号：-注册-x2F-调用用户函数"><a href="#捕捉信号：-注册-x2F-调用用户函数" class="headerlink" title="捕捉信号： 注册&#x2F;调用用户函数"></a>捕捉信号： 注册&#x2F;调用用户函数</h3><h3 id="执行系统默认动作：-SIG-DFL"><a href="#执行系统默认动作：-SIG-DFL" class="headerlink" title="执行系统默认动作： SIG_DFL"></a>执行系统默认动作： SIG_DFL</h3><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>不能忽略&#x2F;捕获 SIGKILL 和 SIGSTOP ，它们向内核和操作系统提供使进程终止和停止的可靠方法</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handler</span><span class="params">(<span class="type">int</span> sig)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ctrl+c\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Signal %d(MISSING) handler.\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">signal</span>(SIGINT, handler);<span class="comment">//func = SIG_IGN/handler/SIG_DFL</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program is running...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>kill命令默认的信号就是15，也就是 kill -15,被称为优雅的退出。</p>
<p>当使用kill -15时，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的。</p>
<p>kill -9就相对强硬一点，系统会发出SIGKILL信号，他要求接收到该信号的程序应该立即结束运行，不能被阻塞或者忽略。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/46d8db601c78.html" data-id="clhh55tud00256cai7iqv6j8c" data-title="信号" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/动态链接" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/57066fae37e1.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/57066fae37e1.html">动态链接</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>用动态链接方法将程序与共享库函数链接：减少可执行文件的长度、库函数的新版本替代老版本无需对该库的程序重新链接</p>
<p>装载时重定位：模块装载地址确定，程序对绝对地址引用重定位。但，动态链接模块lib2.so被装载映射后，指令部分是共享的，修改之后无法共享，因为在不同的进程中动态链接模块lib1.so加载地址不同。</p>
<p>地址无关代码：<br>​	模块内部调用&#x2F;数据：不用重定位<br>​	模块数据间：在数据段（数据段不共享）中建立全局偏移表<em>GOT</em>（指向变量的指针数组），GOT在模块装载时进行修改（GOT与当前代码段的偏移是固定的）</p>
<p>延迟绑定：第一次用的时候才进行绑定</p>
<p>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/57066fae37e1.html" data-id="clhh55tud00276caih8azhof2" data-title="动态链接" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/堆" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/9ccb6b2a0c6b.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/9ccb6b2a0c6b.html">堆</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="malloc-分配虚拟内存-，真正用的时候会发生缺页中断"><a href="#malloc-分配虚拟内存-，真正用的时候会发生缺页中断" class="headerlink" title="malloc : 分配虚拟内存 ，真正用的时候会发生缺页中断"></a>malloc : 分配虚拟内存 ，真正用的时候会发生缺页中断</h2><p>大多数实现所分配的存储空间要稍大一些，额外的空间用来记录管理信息</p>
<h3 id="申请空间-lt-128k"><a href="#申请空间-lt-128k" class="headerlink" title="申请空间 &lt; 128k"></a>申请空间 &lt; 128k</h3><p>sbrk 系统调用：扩充、减少进程的堆</p>
<p>大多数malloc free 的实现都不减小进程的存储空间，将释放的空间<em>保持在malloc 池中</em>而不返回给内核</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//cat /proc/pid/maps</span></span><br><span class="line"><span class="comment">//555cbac37000-555cbac58000 rw-p 00000000 00:00 0   [heap] </span></span><br><span class="line">    <span class="type">int</span> x; cin &gt;&gt; x;<span class="comment">//50 </span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">void</span>*&gt; <span class="title">v</span><span class="params">(x*<span class="number">1e5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        v[i] = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]</span></span><br><span class="line">    <span class="type">int</span> y;cin &gt;&gt; y ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        <span class="comment">// malloc(10);</span></span><br><span class="line">        <span class="built_in">free</span>(v[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]</span></span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>;i&lt;=<span class="number">1ll</span>*x*<span class="number">1e5</span> ;i++)&#123;</span><br><span class="line">        v[i] = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//555cbac37000-555cc44f8000 rw-p 00000000 00:00 0   [heap]    </span></span><br><span class="line">    cin &gt;&gt; y;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="申请空间-gt-x3D-128k"><a href="#申请空间-gt-x3D-128k" class="headerlink" title="申请空间 &gt;&#x3D; 128k"></a>申请空间 &gt;&#x3D; 128k</h3><p>使用mmap的方式申请内存，mmap 以<em>匿名映射</em>的方式从文件映射区分配的匿名内存，free的时候会把内存归还给os</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741c4000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;cin &gt;&gt; x;</span><br><span class="line">    <span class="type">void</span> * p1 = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);<span class="comment">//12&amp;*1024</span></span><br><span class="line">    cout&lt;&lt;p1 &lt;&lt; endl;<span class="comment">// 0x7fc7741a3010</span></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741a3000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="type">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">128</span>*<span class="number">1024</span>);<span class="comment">//12&amp;*1024</span></span><br><span class="line">    cout&lt;&lt;p2 &lt;&lt; endl;<span class="comment">// 0x7fc774182010</span></span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc774182000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="built_in">free</span>(p1);<span class="built_in">free</span>(p2);</span><br><span class="line"><span class="comment">// 55c8b8781000-55c8b87a2000 rw-p 00000000 00:00 0                          [heap]</span></span><br><span class="line"><span class="comment">// 7fc7741c4000-7fc7741c8000 rw-p 00000000 00:00 0 </span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/9ccb6b2a0c6b.html" data-id="clhh55tue002a6caic5fm4x48" data-title="堆" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-os/收发网络包" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/6d7e31aae85a.html" class="article-date">
  <time class="dt-published" datetime="2023-05-08T02:33:55.000Z" itemprop="datePublished">2023-05-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>►<a class="article-category-link" href="/categories/note/os/">os</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/6d7e31aae85a.html">收发网络包</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h1><p>为了解决频繁中断带来的性能开销，采用中断和轮询的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据。</p>
<p>当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址</p>
<p>网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p>
<p>暂时屏蔽中断</p>
<p>软中断：  线程会从 Ring Buffer 中获取一个数据帧，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p>
<p>先进入到网络接口层，在这一层会检查报文的合法性</p>
<p>去掉帧头和帧尾</p>
<p>取出 IP 包</p>
<p>传输层取出 TCP 头或 UDP 头</p>
<p>找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p>
<p><img src="/../images/os/%E6%94%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E5%8C%85/image-20230506154800893.png"></p>
<ol>
<li>NIC（网卡） 接收到数据，通过 DMA 方式写入内存(Ring Buffer 和 sk_buff)。</li>
<li>NIC 发出中断请求（IRQ），告诉内核有新的数据过来了。</li>
<li>Linux 内核响应中断，系统切换为内核态，处理 Interrupt Handler，从RingBuffer 拿出一个 Packet， 并处理协议栈，填充 Socket 并交给用户进程。</li>
<li>系统切换为用户态，用户进程处理数据内容。</li>
</ol>
<h1 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h1><p><strong>将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区</strong>。</p>
<p>TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。</p>
<p>对 sk_buff 填充 TCP 头（调整 sk_buff 中 <code>data</code> 的指针）</p>
<p>交给网络层</p>
<p>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 sk_buff 填充帧头和帧尾，接着将 sk_buff 放到网卡的发送队列中</p>
<p>会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 sk_buff，将这个 sk_buff 挂到 RingBuffer 中，接着将 sk_buff 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/6d7e31aae85a.html" data-id="clhh55tuf002c6cai6av799rq" data-title="收发网络包" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/backup/">backup</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/">cpp</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/c-11/">c++11</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/class/">class</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/stl/">stl</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/template/">template</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/thread/">thread</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/waining/">waining</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/cpp/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/">语言相关</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/go/">go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/mysql/">mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/os/">os</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/">计网</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/">传输层</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E4%BC%A0%E8%BE%93%E5%B1%82/TCP/">TCP</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E5%BA%94%E7%94%A8%E5%B1%82/">应用层</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%A1%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%B1%82/">网络层</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/a2320691ce09.html">token</a>
          </li>
        
          <li>
            <a href="/2023/05/b75e23be19eb.html">tmp</a>
          </li>
        
          <li>
            <a href="/2023/05/57f7189c85b4.html">Generics</a>
          </li>
        
          <li>
            <a href="/2023/05/20146d42898b.html">channel</a>
          </li>
        
          <li>
            <a href="/2023/05/fa2a1258122b.html">interface</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 daidai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>daidai</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="daidai">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="daidai">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="daidai">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="daidai" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">daidai</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-os/预读、缓存" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/cc5c4174b9b8.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="预读机制-：-将要读页面的附近页面也加载进来"><a href="#预读机制-：-将要读页面的附近页面也加载进来" class="headerlink" title="预读机制 ： 将要读页面的附近页面也加载进来"></a>预读机制 ： 将要读页面的附近页面也加载进来</h2><ol>
<li><p>好处<em>减少了 磁盘 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量。</em></p>
</li>
<li><p>问题 : <strong>预读失效</strong> ： 提前被加载进来的页，并没有被访问；<strong>缓存污染</strong>：当我们在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到活跃 LRU 链表里，然后之前缓存在活跃 LRU 链表（或者 young 区域）里的热点数据全部都被淘汰了，<strong>如果这些大量的数据在很长一段时间都不会被访问的话，那么整个活跃 LRU 链表（或者 young 区域）就被污染了</strong>，<strong>不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率</strong> </p>
</li>
<li><p>解决：要避免预读失效带来影响，最好就是<strong>让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在内存里的时间尽可能长</strong>。</p>
</li>
</ol>
<h2 id="Linux-解决方案"><a href="#Linux-解决方案" class="headerlink" title="Linux 解决方案"></a>Linux 解决方案</h2><p>采用两个链表 ：活跃LRU  active list  非活跃LRU inactive  list </p>
<p><strong>预读页就只需要加入到 inactive list 区域的头部，当页被真正访问的时候，才将页插入 active list 的头部</strong>。在内存页被访问第二次的时候，才将页从 inactive list 升级到 active list 里。active list 末尾的页，会被<strong>降级</strong>到 inactive list 的头部，而此时 inactive list 末尾的页（10号）会被淘汰掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/cc5c4174b9b8.html" data-id="clh7jym4b0025cfai82a15jyn" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/AOF" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/3e66ff765467.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>AOF（append only file）持久化：以独立日志的方式记录每次<strong>写命令</strong>，Redis重启时会重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是<strong>解决了数据持久化的实时性</strong></p>
<p>被写入aof文件的所用命令都是以redis的命令请求协议格式保存的</p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>AOF以<code>append-only</code>的模式写入，所以没有磁盘寻址的开销，写入性能非常高</p>
<ol>
<li><p>命令追加</p>
<p> <strong>执行完</strong>写命令之后 ， 以协议格式将写命令追加到 aof_buf 的末尾</p>
</li>
<li><p>文件写入</p>
<p> 将aof_buf中的都写到aof文件</p>
</li>
<li><p>文件同步</p>
<ul>
<li><p>always 每个事件循环</p>
</li>
<li><p>everysec 由一个线程专门负责</p>
</li>
<li><p>no  何时同步由os决定</p>
</li>
</ul>
</li>
</ol>
<p>用户调用<code>write</code>，将数据写到文件,OS会将数据写到内核缓冲区，等缓冲区满&#x2F;超过时间限制，才会写入磁盘。如果计算机停机，保存在内核缓冲区里的数据会丢失。</p>
<p>OS提供<code>fsync/fdatasync </code>两个同步函数，强制os 将缓冲区里的写到磁盘</p>
<h2 id="aof重写"><a href="#aof重写" class="headerlink" title="aof重写"></a>aof重写</h2><p>可以解决aof文件膨胀。</p>
<p>通过读取服务器<strong>当前的数据库状态</strong>实现，新的aof文件不会浪费任何硬盘空间</p>
<h2 id="aof后台重写"><a href="#aof后台重写" class="headerlink" title="aof后台重写"></a>aof后台重写</h2><p><strong>子进程</strong>重写期间，父进程可以继续处理命令请求。</p>
<p>使用fork子进程而非子线程，可以避在使用锁的情况下，保证数据的安全性。</p>
<p><strong>aof重写缓冲区</strong> : 创建子进程之后开始使用 ，同时将写命令写入 aof缓冲区，aof重写缓冲区。</p>
<p>aof缓冲区中的内容写入和同步到aof文件，对现有文件处理正常。</p>
<p>aof重写完成后，向父进程发送信号，父进程收到信号将aof重写缓冲区中的内容写到<strong>新aof文件</strong>，对新的aof文件改名，<strong>原子性覆盖现有文件</strong>。</p>
<h2 id="aof文件载入与数据还原"><a href="#aof文件载入与数据还原" class="headerlink" title="aof文件载入与数据还原"></a>aof文件载入与数据还原</h2><p>读入并重新执行一遍aof文件里的写命令</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>对于同一份文件AOF文件比RDB数据快照要大。</li>
<li>数据恢复比较慢。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/3e66ff765467.html" data-id="clh7jym4h0027cfai623l48ey" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/RDB+AOF" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/bafd5da15776.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>结合RDB 恢复速度快和AOF 丢失数据少的优点</p>
<p>RDB在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少.</p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 <strong>RDB</strong> 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在<strong>重写缓冲区</strong>里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p>
<p>AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/bafd5da15776.html" data-id="clh7jym4h0029cfai0i6og764" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/RDB" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/909524cfaf00.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p><strong>Redis 加载 RDB 恢复数据远远快于 AOF 的方式</strong></p>
<h2 id="坏处"><a href="#坏处" class="headerlink" title="坏处"></a>坏处</h2><p><strong>RDB方式数据无法做到实时持久化</strong>。如果系统恰好在 RDB 快照文件创建完毕后崩溃了，那么 Redis 将会丢失主线程在快照期间修改的数据。</p>
<p><code>BGSAVE</code>每次运行都要执行<code>fork</code>操作创建子进程，属于重量级操作，频繁执行成本比较高。</p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>经过压缩的二进制文件 </p>
<h3 id="手动保存"><a href="#手动保存" class="headerlink" title="手动保存"></a>手动保存</h3><p>SAVE 阻塞服务器进程 </p>
<p>BGSAVE 派生出子进程 fork </p>
<h3 id="自动保存"><a href="#自动保存" class="headerlink" title="自动保存"></a>自动保存</h3><p>save x y ：x秒内，对数据库进行y次修改</p>
<ul>
<li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li>
<li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li>
</ul>
<h2 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h2><p>RDB文件的载入工作服务器启动时自动执行，由于aof文件更新频率比RDB更新频率高，服务器优先选择使用aof来还原数据</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/909524cfaf00.html" data-id="clh7jym4j002bcfaiehq8bud6" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/Sentinel" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/8d3b77098bb4.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>高可用：主从复制(全量数据同步)+ 哨兵</strong><br><strong>读写分离</strong></p>
<p>sentinel的作用是实现主从节点故障转移<br>它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<p>sentinel本质上是一个运行在特殊模式下的redis服务器</p>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>命令连接 + 订阅连接<br>每10秒一次，通过命令连接发送INFO，获得服务器信息<br>  主 ： 自身信息+ 从节点信息<br>  从 ： 主的IP , 从的优先级、复制偏移量<br>  通过命令连接向主从发送 <code>publish <strong>sentinel</strong>:hello  sentinel </code>+ 主的信息<br>  —&gt; 一个sentinel 发送的会被用于更新其他sentinel 对sentinel 以及被监视服务器的认知</p>
<p>  sentinel 之间 ：命令连接 (不需要订阅连接：Sentinel 需要通过接收主&#x2F;从发来的频道信息发现未知的新sentinel  )</p>
<h3 id="检测下线"><a href="#检测下线" class="headerlink" title="检测下线"></a>检测下线</h3><p>每隔一秒给所有主从+sentinel  节点发送PING，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。<br>从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「主观下线」</p>
<p>客观下线只适用于主节点。<br>可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。为了减少误判<br>一个sentinel 主观下线，会向同样检测该主server的其他sentinel 进行询问，得到足够多的已下线判断之后，sentinel 判定为客观下线 –&gt; 故障转移</p>
<h3 id="选leader"><a href="#选leader" class="headerlink" title="选leader"></a>选leader</h3><p>先选领头sentinel ，由 leader sentinel 进行转移转移</p>
<p>选领头sentinel :<br>每个发现主服务器客观下线的sentinel 都要求其他sentinel 将自己设置成局部领头sentinel<br>设置局部领头sentinel 原则 ： 先到先得<br>如果某个sentinel 被半数以上的sentinel 设置成局部领头sentinel ，那么 sentinel 将成为领头sentinel  </p>
<p>一段时间后，没有领头sentinel ，再次选举，直到选出leader sentinel </p>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>选新主server：<br>    根据优先级、复制偏移量、运行ID选新的主节点<br>将从节点指向新主节点<br>  所有的从服务器去复制新的主服务器<br>  通知客户的主节点已更换<br>  通过订阅&#x2F;发布机制<br>  将旧的主节点变为从服务器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/8d3b77098bb4.html" data-id="clh7jym4k002dcfaiblrj8o9r" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/tmp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/19328018007a.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="/../images/redis/tmp/image-20230416124939553.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/19328018007a.html" data-id="clh7jym4l002fcfaihvgjdo77" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/tmp2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/4daa689d479e.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>单线程快（没有竞争） ，操作内存 ，多路复用机制，高效的数据结构 </p>
<p><img src="/../images/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/image-20230416131719255.png"></p>
<p>select &#x2F;epoll 提供基于事件的回调机制</p>
<p>这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，<br>Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，<br>Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件<br>的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升<br>Redis 的响应性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/4daa689d479e.html" data-id="clh7jym4l002hcfaia7ej2iiw" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/主从复制" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/007432a6d630.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>完整重同步<br>    主：生成RDB、传输RDB</p>
<p>部分重同步：<strong>复制偏移量，复制积压缓冲区，服务器运行ID</strong><br>主从都维护复制偏移量</p>
<p>断线重连：从server向主server 发ID、offset </p>
<p>命令传播 ：写命令发到从服务器+复制挤压缓冲区</p>
<p>心跳检测：从向主发当前的复制偏移量，主服务器可以用复制偏移量来检测命令丢失</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/007432a6d630.html" data-id="clh7jym4n002jcfai761c40a0" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/427f68f23e70.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/427f68f23e70.html" data-id="clh7jym4n002lcfai6a6f7ozo" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis/场景应用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/99243f31161e.html" class="article-date">
  <time class="dt-published" datetime="2023-05-03T10:05:17.239Z" itemprop="datePublished">2023-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/note/">note</a>
  </div>

  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>String<br>  Int SDS  embstr</p>
<ol>
<li>常规计数器：因为 Redis 处理命令是单线程，所以执行命令的过程是原子的</li>
<li>分布式锁  set  lock_key  unique_value  NX  PX  10000   </li>
<li>共享session<br>  <strong>String 类型并不是适用于所有场合的，它有一个明显的短板，就是它保存数据时所消耗的内存空间较多。可以改用以压缩列表作为底层的对象</strong></li>
</ol>
<p>List<br>双向链表&#x2F;压缩列表</p>
<ol>
<li>消息队列（不支持多个消费者消费同一条消息）</li>
</ol>
<p>Hash<br>压缩列表&#x2F;哈希表</p>
<ol>
<li>购物车</li>
</ol>
<p>Set<br>哈希表&#x2F;整数集合</p>
<ol>
<li>共同关注</li>
</ol>
<p>Zset<br>  压缩列表或跳表 </p>
<ol>
<li>排行榜</li>
<li>电话、姓名排序</li>
</ol>
<p>Stream<br>  发布订阅模式，<strong>不能持久化</strong>也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；<br>  List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</p>
<ol>
<li>专门为消息队列设计的</li>
</ol>
<p>Bitmap<br>    打卡签到</p>
<p>GEO<br>    存储地理位置信息
    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/99243f31161e.html" data-id="clh7jym4o002ncfai9gu432wv" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/note/">note</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/e4241cb5f901.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/688307dd2a74.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/3100c0d60cf1.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/6e0ab8664bab.html">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/05/1ed1cddfd6c6.html">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 daidai<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>